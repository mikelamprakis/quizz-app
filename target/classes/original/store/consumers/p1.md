## Question 1

Which of the following is stored in the Kafka `__consumer_offsets` topic? (Select two)

* A. The latest committed offset for each consumer group
* B. The list of consumers in each consumer group
* C. The mapping of partitions to consumer groups
* D. The last produced message for each topic partition
* E. The earliest committed offset for each consumer group

<details><summary>Response:</summary>

**Answer:** A, C

**Explanation:**
The `__consumer_offsets` topic stores the **latest committed offsets** (A) and the **partition-to-consumer-group mapping** (C). This allows Kafka to manage consumer group progress.

* B is managed by the group coordinator, not stored in the topic.
* D is stored in the actual topic partitions.
* E is incorrect because only the **latest** committed offset is retained.

</details>

---

## Question 2

There are two consumers C1 and C2 belonging to the same group G subscribed to topics T1, T2, and T3. Each topic has 4 partitions. Assuming all partitions have data, how many partitions will each consumer be assigned with the Range Assignor?

* A. C1: 6 partitions, C2: 6 partitions
* B. C1: 4 partitions, C2: 8 partitions
* C. C1: 2 partitions from each topic, C2: 2 partitions from each topic
* D. C1: 1 partition from each topic, C2: 3 partitions from each topic

<details><summary>Response:</summary>

**Answer:** A

**Explanation:**
With the **Range Assignor**, partitions are assigned topic-by-topic in contiguous blocks. For each topic with 4 partitions and 2 consumers, each consumer gets 2 partitions.
Since there are 3 topics, each consumer gets `2 * 3 = 6` partitions.

</details>

---

## Question 3

There are four consumers C1, C2, C3, C4 belonging to the same group G subscribed to two topics T1 and T2. T1 has 3 partitions and T2 has 2 partitions. With the Round Robin Assignor, which consumer(s) will be assigned partition 2 from topic T1?

* A. C1
* B. C2
* C. C3
* D. C4

<details><summary>Response:</summary>

**Answer:** C

**Explanation:**
The **Round Robin Assignor** assigns partitions one-by-one to consumers in order. With 5 partitions and 4 consumers, the assignment is:

* C1: T1-0, T2-1
* C2: T1-1, T2-0
* C3: T1-2
* C4: (no partitions)
  Thus, **C3** gets partition 2 from topic T1.

</details>

---

## Question 4

There are three consumers C1, C2, C3 belonging to the same group G subscribed to a topic T. The topic has 10 partitions. If the Sticky Assignor is used, and C1 leaves the group, how will the partitions be rebalanced?

* A. All partitions will be reassigned evenly among C2 and C3
* B. C2 and C3 will retain their existing partitions, and the partitions from C1 will be reassigned to either C2 or C3
* C. All partitions will be reassigned randomly to C2 and C3
* D. C2 and C3 will retain their existing partitions, and the partitions from C1 will not be reassigned

<details><summary>Response:</summary>

**Answer:** B

**Explanation:**
The **Sticky Assignor** aims to preserve existing assignments as much as possible. When C1 leaves, its partitions are redistributed **with minimal disruption** to C2 and C3's current assignments.
This minimizes partition movement and keeps consumption stable.

</details>

---

## Question 5

A Kafka Streams application tries to consume from an input topic partition. It receives an 'Offset Out Of Range' error from the broker. How should the application handle this?

* A. Reset the consumer offset to the earliest offset and retry
* B. Reset the consumer offset to the latest offset and retry
* C. Trigger a shutdown of the Streams application
* D. Ignore the error and continue processing other partitions

<details><summary>Response:</summary>

**Answer:** A

**Explanation:**
An **'Offset Out Of Range'** error means the application is trying to read from an offset that no longer exists (usually due to retention limits).
The correct action is to reset the offset to the **earliest** and retry.

* B would skip over data.
* C is an overreaction.
* D causes loss of data for the affected partition.

</details>


Here is your adjusted version using the specified template for Questions 6–10:

---

## Question 6

You are designing a Kafka consumer application that will consume messages from a topic. The messages in the topic are in JSON format. Which of the following properties should you set in the consumer configuration?

* A. `key.deserializer=JsonDeserializer`
* B. `value.deserializer=JsonDeserializer`
* C. `key.deserializer=StringDeserializer`
* D. `value.deserializer=StringDeserializer`

<details><summary>Response:</summary>

**Answer:** B

**Explanation:**
Since the Kafka topic contains JSON messages, the consumer must use a deserializer capable of converting JSON into Java objects. This means the value deserializer should be set to `JsonDeserializer`. The key format isn't specified, so we cannot assume it is JSON—thus, we only set the deserializer for the value.

</details>

---

## Question 7

A consumer wants to read messages from a specific partition of a topic. Which of the following methods should be used?

* A. `KafkaConsumer.subscribe(String topic, int partition)`
* B. `KafkaConsumer.assign(Collection<TopicPartition> partitions)`
* C. `KafkaConsumer.subscribe(Collection<TopicPartition> partitions)`
* D. `KafkaConsumer.assign(String topic, int partition)`

<details><summary>Response:</summary>

**Answer:** B

**Explanation:**
To read from a specific partition, a Kafka consumer should call `assign(Collection<TopicPartition>)`. This bypasses Kafka’s default partition assignment and lets you manually specify exactly which partition(s) the consumer should read from.

</details>

---

