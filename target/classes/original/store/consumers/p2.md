## Question 8

What happens when a consumer is assigned a partition that does not exist in the Kafka cluster?

* A. The consumer will ignore the non-existent partition and continue processing other assigned partitions
* B. The consumer will throw an exception and stop processing
* C. The consumer will create the partition automatically
* D. The consumer will wait until the partition is created

<details><summary>Response:</summary>

**Answer:** B

**Explanation:**
If a consumer is assigned to a non-existent partition, it will throw an exception like `UnknownTopicOrPartitionException` and stop processing. Kafka does not support dynamic creation of partitions by the consumer.

</details>

---

## Question 9

Can a consumer dynamically change the partitions it is assigned to without stopping and restarting?

* A. Yes, by calling `KafkaConsumer.subscribe()` with a new set of topics
* B. Yes, by calling `KafkaConsumer.assign()` with a new set of partitions
* C. No, partition assignment can only be changed when the consumer is first started
* D. No, partition assignment is fixed for the entire lifecycle of the consumer

<details><summary>Response:</summary>

**Answer:** B

**Explanation:**
Calling `assign()` with a new set of `TopicPartition` objects allows a consumer to dynamically change its partition assignments at runtime without restarting.

</details>

---

## Question 10

A consumer is part of a consumer group and is currently processing messages. If the consumer crashes and is restarted, what will happen?

* A. The consumer will resume processing from the last committed offset
* B. The consumer will start processing from the earliest available offset
* C. The consumer will start processing from the latest available offset
* D. The consumer will be assigned a new set of partitions

<details><summary>Response:</summary>

**Answer:** A

**Explanation:**
When a consumer crashes and restarts, it rejoins the group and resumes from the last committed offset. This ensures no message loss or duplication as long as offsets are committed regularly.

</details>


Sure! Here are the adjusted questions using your provided format:

---

## Question 11

What happens when a new consumer joins an existing consumer group?

* A. The new consumer will start consuming from the earliest available offset for all partitions
* B. The new consumer will start consuming from the latest available offset for all partitions
* C. The new consumer will be assigned a subset of partitions and start consuming from the last committed offset for each partition
* D. The new consumer will wait until the next rebalance before starting to consume

<details><summary>Response:</summary>

**Answer:** C

**Explanation:**
When a new consumer joins an existing consumer group, Kafka triggers a rebalance to redistribute the partitions among all consumers, including the new one. Each consumer is then assigned a subset of the topic partitions and starts consuming from the last committed offset.
Unless configured otherwise (e.g., with `auto.offset.reset`), the consumer resumes from where the group left off.

</details>

---

## Question 12

What is the purpose of the `group.id` property in a Kafka consumer configuration?

* A. To specify the ID of the consumer within a consumer group
* B. To specify the ID of the consumer group the consumer belongs to
* C. To specify the ID of the Kafka cluster the consumer connects to
* D. To specify the ID of the partitions the consumer should read from

<details><summary>Response:</summary>

**Answer:** B

**Explanation:**
The `group.id` identifies the consumer group the consumer belongs to. All consumers with the same `group.id` coordinate to consume partitions of a topic collectively, ensuring each partition is only processed by one consumer within the group.

</details>

---

## Question 13

What is the default behavior of the `auto.offset.reset` configuration in Kafka consumers?

* A. It starts consuming from the earliest offset if no committed offset is found
* B. It starts consuming from the latest offset if no committed offset is found
* C. It throws an exception if no committed offset is found
* D. It waits for a committed offset to be available before starting consumption

<details><summary>Response:</summary>

**Answer:** B

**Explanation:**
By default, `auto.offset.reset=latest`, which means the consumer will begin consuming from the latest offset if no committed offset is found. This avoids reading historical data. To start from the beginning instead, set `auto.offset.reset=earliest`.

</details>

---

## Question 14

What happens when a Kafka consumer with `enable.auto.commit=false` calls the `commitSync()` method?

* A. The consumer commits the offsets of the messages it has processed so far
* B. The consumer commits the offsets of the messages it has fetched but not yet processed
* C. The consumer does not commit any offsets and throws an exception
* D. The consumer waits for the next batch of messages to be processed before committing offsets

<details><summary>Response:</summary>

**Answer:** A

**Explanation:**
With `enable.auto.commit=false`, the consumer is responsible for committing offsets manually. Calling `commitSync()` will block until the offsets of the records already processed are committed to Kafka.

</details>

---

